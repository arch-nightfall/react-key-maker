{"version":3,"file":"index.cjs","sources":["../src/index.js"],"sourcesContent":["export function useAutoKeyMaker(options = { prefix: \"\", hash: false }) {\r\n  const { prefix, hash } = options;\r\n  const memoizedKeys = new Map();\r\n  const itemCache = new Map();\r\n  let counter = 0; // Counter for generating incremental keys\r\n\r\n  const resetKeyGenerator = () => {\r\n    memoizedKeys.clear();\r\n    itemCache.clear();\r\n    counter = 0; // Reset the counter\r\n  };\r\n\r\n  const generateKey = (item) => {\r\n    if (!hash) {\r\n      const key = `${prefix}${counter}`;\r\n      counter++; // Increment the counter after generating the key\r\n      return key;\r\n    }\r\n\r\n    const key = customHash(JSON.stringify(item));\r\n    return `${prefix || \"autoKey_\"}${key}`; // Fallback to \"autoKey_\" if prefix is not provided\r\n  };\r\n\r\n  if (typeof options !== \"object\" || options === null) {\r\n    throw new Error(\"Options must be an object.\");\r\n  }\r\n\r\n  if (typeof prefix !== \"string\" && !hash) {\r\n    // Only enforce prefix as string if hash is false\r\n    throw new Error(\"Prefix must be a string.\");\r\n  }\r\n\r\n  function customHash(s) {\r\n    if (!s) return 0;\r\n\r\n    let hash = 0;\r\n    for (let i = 0; i < s.length; i++) {\r\n      const charCode = s.charCodeAt(i);\r\n      hash = (hash << 5) + hash + charCode;\r\n      hash = hash & 0x7fffffff;\r\n    }\r\n    return hash;\r\n  }\r\n\r\n  return {\r\n    keyGen: (item) => {\r\n      if (typeof item !== \"object\" || item === null) {\r\n        throw new Error(\"Item must be an object.\");\r\n      }\r\n\r\n      const key = generateKey(item);\r\n\r\n      // Check if the key exists in the memoized keys\r\n      if (memoizedKeys.has(key)) {\r\n        return memoizedKeys.get(key);\r\n      }\r\n\r\n      // Generate the key if not found in memoized keys\r\n      const newItemKey = key;\r\n\r\n      // Set the generated key in memoized keys\r\n      memoizedKeys.set(key, newItemKey);\r\n\r\n      // Cache the item with its key\r\n      itemCache.set(item, newItemKey);\r\n\r\n      return newItemKey;\r\n    },\r\n    resetKeyGenerator,\r\n  };\r\n}\r\n"],"names":["options","prefix","hash","memoizedKeys","Map","itemCache","counter","Error","keyGen","item","key","s","i","length","charCodeAt","customHash","JSON","stringify","generateKey","has","get","newItemKey","set","resetKeyGenerator","clear"],"mappings":"iCAAgCA,QAAAA,IAAAA,IAAAA,EAAU,CAAEC,OAAQ,GAAIC,MAAM,IAC5D,IAAQD,EAAiBD,EAAjBC,OAAQC,EAASF,EAATE,KACVC,EAAe,IAAIC,IACnBC,EAAY,IAAID,IAClBE,EAAU,EAmBd,GAAuB,iBAAZN,GAAoC,OAAZA,EACjC,MAAM,IAAIO,MAAM,8BAGlB,GAAsB,iBAAXN,IAAwBC,EAEjC,MAAM,IAAIK,MAAM,4BAelB,MAAO,CACLC,OAAQ,SAACC,GACP,GAAoB,iBAATA,GAA8B,OAATA,EAC9B,MAAM,IAAIF,MAAM,2BAGlB,IAAMG,EAtCU,SAACD,GACnB,IAAKP,EAAM,CACT,IAAMQ,KAAST,EAASK,EAExB,OADAA,IACOI,CACT,CAEA,IAAMA,EAaR,SAAoBC,GAClB,IAAKA,EAAG,SAGR,IADA,IAAIT,EAAO,EACFU,EAAI,EAAGA,EAAID,EAAEE,OAAQD,IAE5BV,GAAQA,GAAQ,GAAKA,EADJS,EAAEG,WAAWF,GAE9BV,GAAc,WAEhB,OAAOA,CACT,CAvBca,CAAWC,KAAKC,UAAUR,IACtC,UAAUR,GAAU,YAAaS,CACnC,CA6BgBQ,CAAYT,GAGxB,GAAIN,EAAagB,IAAIT,GACnB,OAAOP,EAAaiB,IAAIV,GAI1B,IAAMW,EAAaX,EAQnB,OALAP,EAAamB,IAAIZ,EAAKW,GAGtBhB,EAAUiB,IAAIb,EAAMY,GAEbA,CACT,EACAE,kBA9DwB,WACxBpB,EAAaqB,QACbnB,EAAUmB,QACVlB,EAAU,CACZ,EA4DF"}